{
	"title": "The Assessment Test",
	"questions": [
    	{
        	"number": 1,
        	"title": "What is the result of executing the following code snippet?",
        	"code": "41: final int score1 = 8, score2 = 3;\n42: char myScore = 7;\n43: var goal = switch (myScore) {\n44:    default -> {if(10>score1) yield \"unknown\";}\n45:    case score1 -> \"great\";\n46:    case 2, 4, 6 -> \"good\";\n47:    case score2, 0 -> {\"bad\";}\n48: };\n49: System.out.println(goal);",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "unknown" },
            	{ "id": "B", "text": "great" },
            	{ "id": "C", "text": "good" },
            	{ "id": "D", "text": "bad" },
            	{ "id": "E", "text": "unknowngreatgoodbad" },
            	{ "id": "F", "text": "Exactly one line needs to be changed for the code to compile" },
            	{ "id": "G", "text": "Exactly two lines need to be changed for the code to compile" },
            	{ "id": "H", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["G"],
            	"explanation": "The question does not compile because line 44 and line 47 do not always return a value in the case block, which is required when a switch expression is used in an assignment operation. Line 44 is missing a yield statement when the if statement evaluates to false, while line 47 is missing a yield statement entirely. Since two lines don't compile, option G is the answer. For more information, see Chapter 3."
            }
        },
    	{
        	"number": 2,
        	"title": "What is the output of the following code snippet?",
        	"code": "int moon = 9, star = 2 + 2 * 3;\nfloat sun = star>10 ? 1 : 3;\ndouble jupiter = (sun + moon) - 1.0f;\nint mars = --moon <= 8 ? 2 : 3;\nSystem.out.println(sun+\", \"+jupiter+\", \"+mars);",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "1, 11, 2" },
            	{ "id": "B", "text": "3.0, 11.0, 2" },
            	{ "id": "C", "text": "1.0, 11.0, 3" },
            	{ "id": "D", "text": "3.0, 13.0, 3" },
            	{ "id": "E", "text": "3.0f, 12, 2" },
            	{ "id": "F", "text": "The code does not compile because one of the assignments requires an explicit numeric cast" }
            ],
        	"answer": {
            	"ids": ["B"],
            	"explanation": "Initially, moon is assigned a value of 9, while star is assigned a value of 8. The multiplication operator (*) has a higher order of precedence than the addition operator (+), so it gets evaluated first. Since star is not greater than 10, sun is assigned a value of 3, which is promoted to 3.0f as part of the assignment. The value of jupiter is (3.0f + 9) - 1.0, which is 11.0f. This value is implicitly promoted to double when it is assigned. In the last assignment, moon is decremented from 9 to 8, with the value of the expression returned as 8. Since 8 less than or equal to 8 is true, mars is set to a value of 2. The final output is 3.0, 11.0, 2, making option B the correct answer. Note that while Java outputs the decimal for both float and double values, it does not output the f for float values. For more information, see Chapter 2."
            }
        },
    	{
        	"number": 3,
        	"title": "Which changes, when made independently, guarantee the following code snippet prints 100 at runtime? (Choose all that apply.)",
        	"code": "List<Integer> data = new ArrayList<>();\nIntStream.range(0,100).parallel().forEach(s -> data.add(s));\nSystem.out.println(data.size());",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "Change data to an instance variable and mark it volatile" },
            	{ "id": "B", "text": "Remove parallel() in the stream operation" },
            	{ "id": "C", "text": "Change forEach() to forEachOrdered() in the stream operation" },
            	{ "id": "D", "text": "Change parallel() to serial() in the stream operation" },
            	{ "id": "E", "text": "Wrap the lambda body with a synchronized block" },
            	{ "id": "F", "text": "The code snippet will always print 100 as is" }
            ],
        	"answer": {
            	"ids": ["B","C","E"],
            	"explanation": "The code may print 100 without any changes, but since the data class is not thread-safe, this behavior is not guaranteed. For this reason, option F is incorrect. Option A is also incorrect, as volatile does not guarantee thread-safety. Options B and C are correct, as they both cause the stream to apply the add() operation in a synchronized manner. Option D is incorrect, as serial() is not a stream method. Option E is correct. Synchronization will cause each thread to wait so that the List is modified one element at a time. For more information, see Chapter 13."
            }
        },
    	{
        	"number": 4,
        	"title": "What is the output of this code?",
        	"code": "20: Predicate<String> empty = String::isEmpty;\n21: Predicate<String> notEmpty = empty.negate();\n22:\n23: var result = Stream.generate(() -> \"\")\n24:    .filter(notEmpty)\n25:    .collect(Collectors.groupingBy(k -> k))\n26:    .entrySet()\n27:    .stream()\n28:    .map(Entry::getValue)\n29:    .flatMap(Collection::stream)\n30:    .collect(Collectors.partitioningBy(notEmpty));\n31: System.out.println(result);",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "It outputs {}" },
            	{ "id": "B", "text": "It outputs {false=[], true=[]}" },
            	{ "id": "C", "text": "The code does not compile" },
            	{ "id": "D", "text": "The code does not terminate" }
            ],
        	"answer": {
            	"ids": ["D"],
            	"explanation": "First, this mess of code does compile. However, the source is an infinite stream. The filter operation will check each element in turn to see whether any are not empty. While nothing passes the filter, the code does not terminate. Therefore, option D is correct. For more information, see Chapter 10."
            }
        },
    	{
        	"number": 5,
        	"title": "What is the result of the following program?",
        	"code": "1: public class MathFunctions {\n2:    public static void addToInt(int x, int amountToAdd) {\n3:       x = x + amountToAdd;\n4:    }\n5:    public static void main(String[] args) {\n6:       var a = 15;\n7:       var b = 10;\n8:       MathFunctions.addToInt(a, b);\n9:       System.out.println(a);   } }",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "10" },
            	{ "id": "B", "text": "15" },
            	{ "id": "C", "text": "25" },
            	{ "id": "D", "text": "Compiler error on line 3" },
            	{ "id": "E", "text": "Compiler error on line 8" },
            	{ "id": "F", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["B"],
            	"explanation": "The code compiles successfully, so options D and E are incorrect. The value of a cannot be changed by the addToInt() method, no matter what the method does, because only a copy of the variable is passed into the parameter x. Therefore, a does not change, and the output on line 9 is 15 which is option B. For more information, see Chapter 5."
            }
        },
    	{
        	"number": 6,
        	"title": "Suppose that we have the following property files and code. What values are printed on lines 8 and 9, respectively?",
        	"code": "Penguin.properties\nname=Billy\nage=1\n \nPenguin_de.properties\nname=Chilly\nage=4\n \nPenguin_en.properties\nname=Willy\n \n5: Locale fr = new Locale(\"fr\");\n6: Locale.setDefault(new Locale(\"en\", \"US\"));\n7: var b = ResourceBundle.getBundle(\"Penguin\", fr);\n8: System.out.println(b.getString(\"name\"));\n9: System.out.println(b.getString(\"age\"));",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "Billy and 1" },
            	{ "id": "B", "text": "Billy and null" },
            	{ "id": "C", "text": "Willy and 1" },
            	{ "id": "D", "text": "Willy and null" },
            	{ "id": "E", "text": "Chilly and null" },
            	{ "id": "F", "text": "The code does not compile" }
            ],
        	"answer": {
            	"ids": ["C"],
            	"explanation": "Java will use Penguin_en.properties as the matching resource bundle on line 7. Since there is no match for French, the default locale is used. Line 8 finds a matching key in the Penguin_en.properties file. Line 9 does not find a match in the Penguin_en.properties file; therefore, it has to look higher up in the hierarchy to Penguin.properties. This makes option C the answer. For more information, see Chapter 11."
            }
        },
    	{
        	"number": 7,
        	"title": "What is guaranteed to be printed by the following code? (Choose all that apply.)",
        	"code": "int[] array = {6,9,8};\nSystem.out.println(\"B\" + Arrays.binarySearch(array,9));\nSystem.out.println(\"C\" + Arrays.compare(array,\n  new int[] {6, 9, 8}));\nSystem.out.println(\"M\" + Arrays.mismatch(array,\n  new int[] {6, 9, 8}));",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "B1" },
            	{ "id": "B", "text": "B2" },
            	{ "id": "C", "text": "C-1" },
            	{ "id": "D", "text": "C0" },
            	{ "id": "E", "text": "M-1" },
            	{ "id": "F", "text": "M0" },
            	{ "id": "G", "text": "The code does not compile" }
            ],
        	"answer": {
            	"ids": ["E","D"],
            	"explanation": "The array is allowed to use an anonymous initializer because it is in the same line as the declaration. The results of the binary search are undefined since the array is not sorted. Since the question asks about guaranteed output, options A and B are incorrect. Option D is correct because the compare() method returns 0 when the arrays are the same length and have the same elements. Option E is correct because the mismatch() method returns a -1 when the arrays are equivalent. For more information, see Chapter 4."
            }
        },
    	{
        	"number": 8,
        	"title": "Which functional interfaces complete the following code, presuming variable r exists? (Choose all that apply.)",
        	"code": "6:  ______ x = r.negate();\n7:  ______ y = () -> System.out.println();\n8:  ______ z = (a, b) -> a - b;",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "BinaryPredicate<Integer, Integer>" },
            	{ "id": "B", "text": "Comparable<Integer>" },
            	{ "id": "C", "text": "Comparator<Integer>" },
            	{ "id": "D", "text": "Consumer<Integer>" },
            	{ "id": "E", "text": "Predicate<Integer>" },
            	{ "id": "F", "text": "Runnable" },
            	{ "id": "G", "text": "Runnable<Integer>" }
            ],
        	"answer": {
            	"ids": ["E","C","F"],
            	"explanation": "First, note that option A is incorrect because the interface should beBiPredicate and not BinaryPredicate. Line 6 requires you to know that negate() is a convenience method on Predicate. This makes option E correct. Line 7 takes zero parameters and doesn't return anything, making it a Runnable. Remember that Runnable doesn't use generics. This makes option F correct. Finally, line 8 takes two parameters and returns an int. Option C is correct. Comparable is there to mislead you since it takes only one parameter in its single abstract method. For more information, see Chapter 8."
            }
        },
    	{
        	"number": 9,
        	"title": "Suppose you have a module named com.vet. Where could you place the following module-info.java file to create a valid module?",
        	"code": "public module com.vet {\n   exports com.vet;\n}",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "At the same level as the com folder" },
            	{ "id": "B", "text": "At the same level as the vet folder" },
            	{ "id": "C", "text": "Inside the vet folder" },
            	{ "id": "D", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["D"],
            	"explanation": "If this were a valid module-info.java file, it would need to be placed at the root directory of the module, which is option A. However, a module is not allowed to use the public access modifier. Option D is correct because the provided file does not compile regardless of placement in the project. For more information, see Chapter 12."
            }
        },
    	{
        	"number": 10,
        	"title": "What is the output of the following program? (Choose all that apply.)",
        	"code": "1:  interface HasTail { private int getTailLength(); }\n2:  abstract class Puma implements HasTail {\n3:     String getTailLength() { return \"4\"; }\n4:  }\n5:  public class Cougar implements HasTail {\n6:     public static void main(String[] args) {\n7:        var puma = new Puma() {};\n8:        System.out.println(puma.getTailLength());\n9:     }\n10:    public int getTailLength(int length) { return 2; }\n11: }",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "2" },
            	{ "id": "B", "text": "4" },
            	{ "id": "C", "text": "The code will not compile because of line 1" },
            	{ "id": "D", "text": "The code will not compile because of line 3" },
            	{ "id": "E", "text": "The code will not compile because of line 5" },
            	{ "id": "F", "text": "The code will not compile because of line 7" },
            	{ "id": "G", "text": "The code will not compile because of line 10" },
            	{ "id": "H", "text": "The output cannot be determined from the code provided" }
            ],
        	"answer": {
            	"ids": ["C"],
            	"explanation": "The getTailLength() method in the interface is private; therefore, it must include a body. For this reason, line 1 is the only line that does not compile and option C is correct. Line 3 uses a different return type for the method, but since it is private in the interface, it is not considered an override. Note that line 7 defines an anonymous class using the abstract Puma parent class. For more information, see Chapter 7."
            }
        },
    	{
        	"number": 11,
        	"title": "Which lines in Tadpole.java give a compiler error? (Choose all that apply.)",
        	"code": "// Frog.java\n1:  package animal;\n2:  public class Frog {\n3:     protected void ribbit() { }\n4:     void jump() { }\n5:  }\n \n// Tadpole.java\n1:  package other;\n2:  import animal.*;\n3:  public class Tadpole extends Frog {\n4:     public static void main(String[] args) {\n5:        Tadpole t = new Tadpole();\n6:        t.ribbit();\n7:        t.jump();\n8:        Frog f = new Tadpole();\n9:        f.ribbit();\n10:       f.jump();\n11:    } }",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "Line 5" },
            	{ "id": "B", "text": "Line 6" },
            	{ "id": "C", "text": "Line 7" },
            	{ "id": "D", "text": "Line 8" },
            	{ "id": "E", "text": "Line 9" },
            	{ "id": "F", "text": "Line 10" },
            	{ "id": "G", "text": "All of the lines compile" }
            ],
        	"answer": {
            	"ids": ["E","C","F"],
            	"explanation": "The jump() method has package access, which means it can be accessed only from the same package. Tadpole is not in the same package as Frog, causing lines 7 and 10 to trigger compiler errors and giving us options C and F. The ribbit() method has protected access, which means it can only be accessed from a subclass reference or in the same package. Line 6 is fine because Tadpole is a subclass. Line 9 does not compile and our final answer is option E because the variable reference is to a Frog, which doesn't grant access to the protected method. For more information, see Chapter 5."
            }
        },
    	{
        	"number": 12,
        	"title": "Which of the following can fill in the blanks in order to make this code compile?",
        	"code": "__________ a = __________.getConnection(\n   url, userName, password);\n__________ b = a.prepareStatement(sql);\n__________ c = b.executeQuery();\nif (c.next()) System.out.println(c.getString(1));",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "Connection, Driver, PreparedStatement, ResultSet" },
            	{ "id": "B", "text": "Connection, DriverManager, PreparedStatement, ResultSet" },
            	{ "id": "C", "text": "Connection, DataSource, PreparedStatement, ResultSet" },
            	{ "id": "D", "text": "Driver, Connection, PreparedStatement, ResultSet" },
            	{ "id": "E", "text": "DriverManager, Connection, PreparedStatement, ResultSet" },
            	{ "id": "F", "text": "DataSource, Connection, PreparedStatement, ResultSet" }
            ],
        	"answer": {
            	"ids": ["B"],
            	"explanation": "DataSource isn't on the exam, so any question containing one is wrong. The key variables used in running a query are Connection, PreparedStatement, and ResultSet. A Connection is obtained through a DriverManager, making option B correct. For more information, see Chapter 15."
            }
        },
    	{
        	"number": 13,
        	"title": "Which of the following statements can fill in the blank to make the code compile successfully? (Choose all that apply.)",
        	"code": "Set<? extends RuntimeException> mySet = new _________ ();",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "HashSet<? extends RuntimeException>" },
            	{ "id": "B", "text": "HashSet<Exception>" },
            	{ "id": "C", "text": "TreeSet<RuntimeException>" },
            	{ "id": "D", "text": "TreeSet<NullPointerException>" },
            	{ "id": "E", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["C","D"],
            	"explanation": "The mySet declaration defines an upper bound of type RuntimeException. This means that classes may specify RuntimeException or any subclass of RuntimeException as the type parameter. Option B is incorrect because Exception is a superclass, not a subclass, of RuntimeException. Option A is incorrect because the wildcard cannot occur on the right side of the assignment. Options C and D compile and are the answers. For more information, see Chapter 9."
            }
        },
    	{
        	"number": 14,
        	"title": "Assume that birds.dat exists, is accessible, and contains data for a Bird object. What is the result of executing the following code? (Choose all that apply.)",
        	"code": "1:  import java.io.*;\n2:  public class Bird {\n3:     private String name;\n4:     private transient Integer age;\n5:\n6:     // Getters/setters omitted\n7:\n8:     public static void main(String[] args) {\n9:        try(var is = new ObjectInputStream(\n10:             new BufferedInputStream(\n11:             new FileInputStream(\"birds.dat\")))) {\n12:          Bird b = is.readObject();\n13:          System.out.println(b.age);\n14:       } } }",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "It compiles and prints 0 at runtime" },
            	{ "id": "B", "text": "It compiles and prints null at runtime" },
            	{ "id": "C", "text": "It compiles and prints a number at runtime" },
            	{ "id": "D", "text": "The code will not compile because of lines 9–11" },
            	{ "id": "E", "text": "The code will not compile because of line 12" },
            	{ "id": "F", "text": "It compiles but throws an exception at runtime" }
            ],
        	"answer": {
            	"ids": ["D","E"],
            	"explanation": "Line 10 includes an unhandled checked IOException, while line 11 includes an unhandled checked FileNotFoundException, making option D correct. Line 12 does not compile because is.readObject() must be cast to a Bird object to be assigned to b. It also does not compile because it includes two unhandled checked exceptions, IOException and ClassNotFoundException, making option E correct. If a cast operation were added on line 12 and the main() method were updated on line 8 to declare the various checked exceptions, the code would compile but throw an exception at runtime since Bird does not implement Serializable. Finally, if the class did implement Serializable, the program would print null at runtime, as that is the default value for the transient field age. For more information, see Chapter 14."
            }
        },
    	{
        	"number": 15,
        	"title": "Which of the following are valid instance members of a class? (Choose all that apply.)",
        	"code": null,
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "var var = 3;" },
            	{ "id": "B", "text": "Var case = new Var();" },
            	{ "id": "C", "text": "void var() {}" },
            	{ "id": "D", "text": "int Var() { var _ = 7; return _;}" },
            	{ "id": "E", "text": "String new = \"var\";" },
            	{ "id": "F", "text": "var var() { return null; }" }
            ],
        	"answer": {
            	"ids": ["C"],
            	"explanation": "Option A is incorrect because var is only allowed as a type for local variables, not instance members. Options B and E are incorrect because new and case are reserved words and cannot be used as identifiers. Option C is correct, as var can be used as a method name. Option D is incorrect because a single underscore (_) cannot be used as an identifier. Finally, option F is incorrect because var cannot be specified as the return type of a method. For more information, see Chapter 1."
            }
        },
    	{
        	"number": 16,
        	"title": "Which is true if the table is empty before this code is run? (Choose all that apply.)",
        	"code": "var sql = \"INSERT INTO people VALUES(?, ?, ?)\";\nconn.setAutoCommit(false);\n \ntry (var ps = conn.prepareStatement(sql, \n   ResultSet.TYPE_SCROLL_SENSITIVE,   ResultSet.CONCUR_UPDATABLE)) {\n \n   ps.setInt(1, 1);\n   ps.setString(2, \"Joslyn\");\n   ps.setString(3, \"NY\");\n   ps.executeUpdate();\n \n   Savepoint sp = conn.setSavepoint();\n \n   ps.setInt(1, 2);\n   ps.setString(2, \"Kara\");\n   ps.executeUpdate();\n \n   conn._________________;\n}",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "If the blank line contains rollback(), there are no rows in the table" },
            	{ "id": "B", "text": "If the blank line contains rollback(), there is one row in the table" },
            	{ "id": "C", "text": "If the blank line contains rollback(sp), there are no rows in the table" },
            	{ "id": "D", "text": "If the blank line contains rollback(sp), there is one row in the table" },
            	{ "id": "E", "text": "The code does not compile" },
            	{ "id": "F", "text": "The code throws an exception because the second update does not set all the parameters" }
            ],
        	"answer": {
            	"ids": ["A","D"],
            	"explanation": "This code is correct, eliminating options E and F. JD BC will use the existing parameter set if you don't replace it. This means Kara's row will be set to use NY as the third parameter. Rolling back to a savepoint throws out any changes made since. This leaves Joslyn and eliminates Kara, making option D correct. Rolling back without a savepoint brings us back to the beginning of the transaction, which is option A. For more information, see Chapter 15."
            }
        },
    	{
        	"number": 17,
        	"title": "Which is true if the contents of path1 start with the text Howdy? (Choose two.)",
        	"code": "System.out.println(Files.mismatch(path1,path2));",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "If path2 doesn't exist, the code prints -1" },
            	{ "id": "B", "text": "If path2 doesn't exist, the code prints 0" },
            	{ "id": "C", "text": "If path2 doesn't exist, the code throws an exception" },
            	{ "id": "D", "text": "If the contents of path2 start with Hello, the code prints -1" },
            	{ "id": "E", "text": "If the contents of path2 start with Hello, the code prints 0" },
            	{ "id": "F", "text": "If the contents of path2 start with Hello, the code prints 1" }
            ],
        	"answer": {
            	"ids": ["F","C"],
            	"explanation": "Option C is correct as mismatch() throws an exception if the files do not exist unless they both refer to the same file. Additionally, option F is correct because the first index that differs is returned, which is the second character. Since Java uses zero-based indexes, this is 1. For more information, see Chapter 14."
            }
        },
    	{
        	"number": 18,
        	"title": "Which of the following types can be inserted into the blank to allow the program to compile successfully? (Choose all that apply.)",
        	"code": "1: import java.util.*;\n2: final class Amphibian {}\n3: abstract class Tadpole extends Amphibian {}\n4: public class FindAllTadpoles {\n5:    public static void main(String… args) {\n6:       var tadpoles = new ArrayList<Tadpole>();\n7:       for (var amphibian : tadpoles) {\n8:          ___________   tadpole = amphibian;\n9: } } }",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "List<Tadpole>" },
            	{ "id": "B", "text": "Boolean" },
            	{ "id": "C", "text": "Amphibian" },
            	{ "id": "D", "text": "Tadpole" },
            	{ "id": "E", "text": "Object" },
            	{ "id": "F", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["F"],
            	"explanation": "The Amphibian class is marked final, which means line 3 triggers a compiler error and option F is correct. For more information, see Chapter 6."
            }
        },
    	{
        	"number": 19,
        	"title": "What is the result of compiling and executing the following program?",
        	"code": "1:  public class FeedingSchedule {\n2:     public static void main(String[] args) {\n3:        var x = 5;\n4:        var j = 0;\n5:        OUTER: for (var i = 0; i < 3;)\n6:           INNER: do {\n7:              i++;\n8:              x++;\n9:              if (x> 10) break INNER;\n10:             x += 4;\n11:             j++;\n12:          } while (j <= 2);\n13:       System.out.println(x);\n14: } }",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "10" },
            	{ "id": "B", "text": "11" },
            	{ "id": "C", "text": "12" },
            	{ "id": "D", "text": "17" },
            	{ "id": "E", "text": "The code will not compile because of line 5" },
            	{ "id": "F", "text": "The code will not compile because of line 6" }
            ],
        	"answer": {
            	"ids": ["C"],
            	"explanation": "The code compiles and runs without issue; therefore, options E and F are incorrect. This type of problem is best examined one loop iteration at a time: On the first iteration of the outer loop, i is 0, so the loop continues. On the first iteration of the inner loop, i is updated to 1 and x to 6. The if statement branch is not executed, and x is increased to 10 and j to 1. On the second iteration of the inner loop (since j = 1 and 1 <= 2), i is updated to 2 and x to 11. At this point, the if branch will evaluate to true for the remainder of the program run, which causes the flow to break out of the inner loop each time it is reached. On the second iteration of the outer loop (since i = 2), i is updated to 3 and x to 12. As before, the inner loop is broken since x is still greater than 10. On the third iteration of the outer loop, the outer loop is broken, as i is already not less than 3. The most recent value of x, 12, is output, so the answer is option C. For more information, see Chapter 3."
            }
        },
    	{
        	"number": 20,
        	"title": "When printed, which String gives the same value as this text block?",
        	"code": "var pooh = \"\"\"\n   \"Oh, bother.\" -Pooh\n   \"\"\".indent(1);\nSystem.out.print(pooh);",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "\"\\n\\\"Oh, bother.\\\" -Pooh\\n\"", "isCode": true },
            	{ "id": "B", "text": "\"\\n \\\"Oh, bother.\\\" -Pooh\\n\"", "isCode": true },
            	{ "id": "C", "text": "\" \\\"Oh, bother.\\\" -Pooh\\n\"", "isCode": true },
            	{ "id": "D", "text": "\"\\n\\\"Oh, bother.\\\" -Pooh\"", "isCode": true },
            	{ "id": "E", "text": "\"\\n \\\"Oh, bother.\\\" -Pooh\"", "isCode": true },
            	{ "id": "F", "text": "\" \\\"Oh, bother.\\\" -Pooh\"", "isCode": true },
            	{ "id": "G", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["C"],
            	"explanation": "First, note that the text block has the closing \"\"\" on a separate line, which means there is a new line at the end and rules out options D, E, and F. Additionally, text blocks don't start with a new line, ruling out options A and B. Therefore, option C is correct. For more information, see Chapter 1."
            }
        },
    	{
        	"number": 21,
        	"title": "A(n) _________________ module always contains a module-info.java file, while a(n) _________________ module always exports all its packages to other modules.",
        	"code": null,
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "automatic, named" },
            	{ "id": "B", "text": "automatic, unnamed" },
            	{ "id": "C", "text": "named, automatic" },
            	{ "id": "D", "text": "named, unnamed" },
            	{ "id": "E", "text": "unnamed, automatic" },
            	{ "id": "F", "text": "unnamed, named" },
            	{ "id": "G", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["C"],
            	"explanation": "Only named modules are required to have a module-info.java file, ruling out options A, B, E, and F. Unnamed modules are not readable by any other types of modules, ruling out option D. Automatic modules always export all packages to other modules, making the answer option C. For more information, see Chapter 12."
            }
        },
    	{
        	"number": 22,
        	"title": "What is the result of the following code?",
        	"code": "22: var treeMap = new TreeMap<Character, Integer>();\n23: treeMap.put('k', 1);\n24: treeMap.put('k', 2);\n25: treeMap.put('m', 3);\n26: treeMap.put('M', 4);\n27: treeMap.replaceAll((k, v) -> v + v);\n28: treeMap.keySet()\n29:    .forEach(k -> System.out.print(treeMap.get(k)));",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "268" },
            	{ "id": "B", "text": "468" },
            	{ "id": "C", "text": "2468" },
            	{ "id": "D", "text": "826" },
            	{ "id": "E", "text": "846" },
            	{ "id": "F", "text": "8246" },
            	{ "id": "G", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["E"],
            	"explanation": "When the same key is put into a Map, it overrides the original value. This means that line 23 could be omitted and the code would be the same, and there are only three key/value pairs in the map. TreeMap sorts its keys, making the order M followed by k followed by m. Remember that natural sort ordering has uppercase before lowercase. The replaceAll() method runs against each element in the map, doubling the value. Finally, we iterate through each key, printing 846 and making option E correct. For more information, see Chapter 9."
            }
        },
    	{
        	"number": 23,
        	"title": "Which of the following lines can fill in the blank to print true? (Choose all that apply.)",
        	"code": "10: public static void main(String[] args) {\n11:    System.out.println(test(____________________________));\n12: }\n13: private static boolean test(Function<Integer, Boolean> b) {\n14:    return b.apply(5);\n15: }",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "i::equals(5)" },
            	{ "id": "B", "text": "i -> {i == 5;}" },
            	{ "id": "C", "text": "(i) -> i == 5" },
            	{ "id": "D", "text": "(int i) -> i == 5" },
            	{ "id": "E", "text": "(int i) -> {return i == 5;}" },
            	{ "id": "F", "text": "(i) -> {return i == 5;}" }
            ],
        	"answer": {
            	"ids": ["F","C"],
            	"explanation": "Option A looks like a method reference. However, it doesn't call a valid method, nor can method references take parameters. The Predicate interface takes a single parameter and returns a boolean. Lambda expressions with one parameter are allowed to omit the parentheses around the parameter list, making option C correct. The return statement is optional when a single statement is in the body, making option F correct. Option B is incorrect because a return statement must be used if braces are included around the body. Options D and E are incorrect because the type is Integer in the predicate and int in the lambda. Autoboxing works for collections, not inferring predicates. If these two were changed to Integer, they would be correct. For more information, see Chapter 8."
            }
        },
    	{
        	"number": 24,
        	"title": "How many times is the word true printed?",
        	"code": "var s1 = \"Java\";\nvar s2 = \"Java\";\nvar s3 = s1.indent(1).strip();\nvar s4 = s3.intern();\nvar sb1 = new StringBuilder();\nsb1.append(\"Ja\").append(\"va\");\n \nSystem.out.println(s1 == s2);\nSystem.out.println(s1.equals(s2));\nSystem.out.println(s1 == s3);\nSystem.out.println(s1 == s4);\nSystem.out.println(sb1.toString() == s1);\nSystem.out.println(sb1.toString().equals(s1));",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "Once" },
            	{ "id": "B", "text": "Twice" },
            	{ "id": "C", "text": "Three times" },
            	{ "id": "D", "text": "Four times" },
            	{ "id": "E", "text": "Five times" },
            	{ "id": "F", "text": "The code does not compile" }
            ],
        	"answer": {
            	"ids": ["D"],
            	"explanation": "String literals are used from the string pool. This means that s1 and s2 refer to the same object and are equal. Therefore, the first two print statements print true. While the indent() and strip() methods create new String objects and the third statement prints false, the intern() method reverts the String to the one from the string pool. Therefore, the fourth print statement prints true. The fifth print statement prints false because toString() uses a method to compute the value, and it is not from the string pool. The final print statement again prints true because equals() looks at the values of String objects. Since four are true, option D is the answer. For more information, see Chapter 4."
            }
        },
    	{
        	"number": 25,
        	"title": "What is the output of the following program?",
        	"code": "1:  class Deer {\n2:     public Deer() {System.out.print(\"Deer\");}\n3:     public Deer(int age) {System.out.print(\"DeerAge\");}\n4:     protected boolean hasHorns() { return false; }\n5:  }\n6:  public class Reindeer extends Deer {\n7:     public Reindeer(int age) {System.out.print(\"Reindeer\");}\n8:     public boolean hasHorns() { return true; }\n9:     public static void main(String[] args) {\n10:       Deer deer = new Reindeer(5);\n11:       System.out.println(\",\" + deer.hasHorns());\n12: } }",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "ReindeerDeer,false" },
            	{ "id": "B", "text": "DeerAgeReindeer,true" },
            	{ "id": "C", "text": "DeerReindeer,true" },
            	{ "id": "D", "text": "DeerReindeer,false" },
            	{ "id": "E", "text": "ReindeerDeer,true" },
            	{ "id": "F", "text": "DeerAgeReindeer,false" },
            	{ "id": "G", "text": "The code will not compile because of line 4" },
            	{ "id": "H", "text": "The code will not compile because of line 12" }
            ],
        	"answer": {
            	"ids": ["C"],
            	"explanation": "The Reindeer object is instantiated using the constructor that takes an int value. Since there is no explicit call to the parent constructor, the compiler inserts super() as the first line of the constructor on line 7. The parent constructor is called, and Deer is printed on line 2. The flow returns to the constructor on line 7, with Reindeer being printed. Next, the hasHorns() method is called. The reference type is Deer, and the underlying object type is Reindeer. Since Reindeer correctly overrides the hasHorns() method, the version in Reindeer is called, with line 11 printing ,true. Therefore, option C is correct. For more information, see Chapter 6."
            }
        },
    	{
        	"number": 26,
        	"title": "Which of the following are true? (Choose all that apply.)",
        	"code": "private static void magic(Stream<Integer> s) {\n   Optional o = s\n      .filter(x -> x < 5)      .limit(3)\n      .max((x, y) -> x-y);\n   System.out.println(o.get());\n}",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "magic(Stream.empty()); runs infinitely" },
            	{ "id": "B", "text": "magic(Stream.empty()); throws an exception" },
            	{ "id": "C", "text": "magic(Stream.iterate(1, x -> x++)); runs infinitely" },
            	{ "id": "D", "text": "magic(Stream.iterate(1, x -> x++)); throws an exception" },
            	{ "id": "E", "text": "magic(Stream.of(5, 10)); runs infinitely" },
            	{ "id": "F", "text": "magic(Stream.of(5, 10)); throws an exception" },
            	{ "id": "G", "text": "The method does not compile" }
            ],
        	"answer": {
            	"ids": ["B","F"],
            	"explanation": "Calling get() on an empty Optional causes an exception to be thrown, making option B correct. Option F is also correct because filter() makes the Optional empty before it calls get(). Option C is incorrect because the infinite stream is made finite by the intermediate limit() operation. Options A and E are incorrect because the source streams are not infinite. Therefore, the call to max() sees only three elements and terminates. For more information, see Chapter 10."
            }
        },
    	{
        	"number": 27,
        	"title": "Assuming the following declarations are top-level types declared in the same file, which successfully compile? (Choose all that apply.)",
        	"code": "record Music() {\n   final int score = 10;\n}\nrecord Song(String lyrics) {\n   Song {\n      this.lyrics = lyrics + \"Hello World\";\n   }\n}\nsealed class Dance {}\nrecord March() {\n   @Override String toString() { return null; }\n}\nclass Ballet extends Dance {}",
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "Music" },
            	{ "id": "B", "text": "Song" },
            	{ "id": "C", "text": "Dance" },
            	{ "id": "D", "text": "March" },
            	{ "id": "E", "text": "Ballet" },
            	{ "id": "F", "text": "None of them compile" }
            ],
        	"answer": {
            	"ids": ["C"],
            	"explanation": "Music does not compile because records cannot include instance variables not listed in the declaration of the record, as it could break immutability. Song does not compile because a compact constructor cannot set an instance variable. The record would compile if this were removed from the compact constructor, as compact constructors can modify input parameters. March does not compile because it is an invalid override; it reduces the visibility of the toString() method from public to package access. Ballet does not compile because the subclass of a sealed class must be marked final, sealed, or non-sealed. Since the only one that compiles is Dance, option C is the answer. For more information, see Chapter 7."
            }
        },
    	{
        	"number": 28,
        	"title": "Which of the following expressions compile without error? (Choose all that apply.)",
        	"code": null,
        	"multipleOptions": true,
        	"options": [
            	{ "id": "A", "text": "int monday = 3 + 2.0;" },
            	{ "id": "B", "text": "double tuesday = 5_6L;" },
            	{ "id": "C", "text": "boolean wednesday = 1 > 2 ? !true;" },
            	{ "id": "D", "text": "short thursday = (short)Integer.MAX_VALUE;" },
            	{ "id": "E", "text": "long friday = 8.0L;" },
            	{ "id": "F", "text": "var saturday = 2_.0;" },
            	{ "id": "G", "text": "None of the above" }
            ],
        	"answer": {
            	"ids": ["B","D"],
            	"explanation": "Option A does not compile, as the expression 3 + 2.0 is evaluated as a double, and a double requires an explicit cast to be assigned to an int. Option B compiles without issue, as a long value can be implicitly cast to a double. Option C does not compile because the ternary operator (? :) is missing a colon (:), followed by a second expression. Option D is correct. Even though the int value is larger than a short, it is explicitly cast to a short, which means the value will wrap around to fit in a short. Option E is incorrect, as you cannot use a decimal (.) with the long (L) postfix. Finally, option F is incorrect, as an underscore cannot be used next to a decimal point. For more information, see Chapter 2."
            }
        },
    	{
        	"number": 29,
        	"title": "What is the result of executing the following application?",
        	"code": "final var cb = new CyclicBarrier(3, \n   () -> System.out.println(\"Clean!\"));  // u1\nExecutorService service = Executors.newSingleThreadExecutor();\ntry {\n   IntStream.generate(() -> 1)\n      .limit(12)\n      .parallel()\n      .forEach(i -> service.submit(() -> cb.await()));  // u2\n} finally { service.shutdown(); }",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "It outputs Clean! at least once" },
            	{ "id": "B", "text": "It outputs Clean! exactly four times" },
            	{ "id": "C", "text": "The code will not compile because of line u1" },
            	{ "id": "D", "text": "The code will not compile because of line u2" },
            	{ "id": "E", "text": "It compiles but throws an exception at runtime" },
            	{ "id": "F", "text": "It compiles but waits forever at runtime" }
            ],
        	"answer": {
            	"ids": ["F"],
            	"explanation": "The code compiles without issue. The key to understanding this code is to notice that our thread executor contains only one thread, but our CyclicBarrier limit is 3. Even though 12 tasks are all successfully submitted to the service, the first task will block forever on the call to await(). Since the barrier is never reached, nothing is printed, and the program hangs, making option F correct. For more information, see Chapter 13."
            }
        },
    	{
        	"number": 30,
        	"title": "Which statement about the following method is true?",
        	"code": "5:  public static void main(String… unused) {\n6:     System.out.print(\"a\");\n7:     try (StringBuilder reader = new StringBuilder()) {\n8:        System.out.print(\"b\");\n9:        throw new IllegalArgumentException();\n10:    } catch (Exception e || RuntimeException e) {\n11:       System.out.print(\"c\");\n12:       throw new FileNotFoundException();\n13:    } finally {\n14:       System.out.print(\"d\");\n15: } }",
        	"multipleOptions": false,
        	"options": [
            	{ "id": "A", "text": "It compiles and prints abc" },
            	{ "id": "B", "text": "It compiles and prints abd" },
            	{ "id": "C", "text": "It compiles and prints abcd" },
            	{ "id": "D", "text": "One line contains a compiler error" },
            	{ "id": "E", "text": "Two lines contain a compiler error" },
            	{ "id": "F", "text": "Three lines contain a compiler error" },
            	{ "id": "G", "text": "It compiles but prints an exception at runtime" }
            ],
        	"answer": {
            	"ids": ["F"],
            	"explanation": "Line 5 does not compile as the FileNotFoundException thrown on line 12 is not handled or declared by the method. Line 7 does not compile because StringBuilder does not implement AutoCloseable and is therefore not compatible with a try-with- resource statement. Finally, line 10 does not compile as RuntimeException is a subclass of Exception in the multi-catch block, making it redundant. Since this method contains three compiler errors, option F is the correct answer. For more information, see Chapter 11."
            }
        }
    ]
}
